<!-- static/index.html (updated) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FrontWave - Viewer</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root { --primary:#0b5fff; --primary-ink:#fff; --muted:#555; }
    body { margin:0; font-family:sans-serif }
    header { background:#333; color:#fff; padding:1rem }
    section.card { margin:1rem; padding:1rem; border:1px solid #ccc; border-radius:8px }
    .row { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center }
    label { font-size:0.9rem }
    select, input[type="number"], input[type="range"] { padding:0.3rem }
    .muted { color:var(--muted); font-size:0.9em }
    #map { height:560px; margin:1rem 0 }
    .table-wrap { overflow:auto; max-height:260px; border:1px solid #ddd }
    table { border-collapse:collapse; width:100% }
    th, td { border:1px solid #ddd; padding:4px 6px; font-size:12px; white-space:nowrap }
    th { background:#f5f5f5; position:sticky; top:0 }
    .chips { display:flex; flex-wrap:wrap; gap:0.5rem; margin:0.5rem 0 }
    .chip { background:#eee; padding:0.4rem 0.8rem; border-radius:18px }
    .legend { background:#fff; padding:.6rem; border:1px solid #ccc; border-radius:6px; line-height:1.1 }
    .legend canvas { display:block; width:180px; height:12px; image-rendering:pixelated; margin:.25rem 0 }
    .legend .ticks { display:flex; justify-content:space-between; font-size:.8rem }
    .ts { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap }
    .ts .grow { flex:1 1 260px }
    .btn { padding:.5rem .9rem; border:1px solid #aaa; background:#f8f8f8; border-radius:8px; cursor:pointer; font-weight:600 }
    .btn-primary { background:var(--primary); color:var(--primary-ink); border-color:var(--primary) }
    .panel { display:flex; gap:1rem; align-items:center; flex-wrap:wrap }
    .vbox { display:flex; gap:.4rem; align-items:center }
    #vel-chart-wrap { width:420px; max-width:100%; background:#fff; border:1px solid #ddd; border-radius:8px; padding:.5rem }
  </style>
</head>
<body>
  <header>
    <h1>FrontWave Tool</h1>
    <h3>Interpolation and velocity with quick stats</h3>
    <p class="muted">1) Load CSV → 2) Check separator and fields → 3) Process → 4) Map and downloads</p>
  </header>

  <section class="card">
    <h2>Step 1 · Load CSV</h2>
    <div class="row">
      <input type="file" id="csvfile" accept=".csv" />
      <label>Separator:
        <select id="sep">
          <option value=";">; (semicolon)</option>
          <option value=",">, (comma)</option>
          <option value="\\t">tab</option>
          <option value="|">| (pipe)</option>
        </select>
      </label>
      <label><input type="checkbox" id="toggle-preview"> Show CSV preview</label>
      <button id="preview" class="btn">Preview</button>
      <button id="process" class="btn btn-primary">Process</button>
    </div>
    <div class="row" style="margin-top:.5rem">
      <label>lon: <select id="lon_field"></select></label>
      <label>lat: <select id="lat_field"></select></label>
      <label>date: <select id="date_field"></select></label>
      <label>id: <select id="id_field"></select></label>
      <label>weight: <select id="weight_field"></select></label>
      <label>cases: <select id="case_field"></select></label>
      <label>grid (m): <input type="number" id="grid" value="12000" style="width:7rem"></label>
      <label>cell (m): <input type="number" id="cell" value="1200" style="width:7rem"></label>
      <label>contour: <input type="number" id="contour" value="30" style="width:6rem"></label>
    </div>
    <div class="table-wrap" id="preview-wrap" style="display:none">
      <table id="preview-table"></table>
    </div>
    <div class="chips" id="preview-info" style="display:none"></div>
  </section>

  <section class="card">
    <h2>Step 2 · Map</h2>

    <div class="row" style="align-items:flex-end">
      <label>Raster layer:
        <select id="raster_layer">
          <option value="velocity">velocity</option>
          <option value="kriging">kriging</option>
          <option value="slope">slope</option>
        </select>
      </label>
      <label>Palette:
        <select id="palette">
          <option value="gray">gray</option>
          <option value="viridis">viridis</option>
          <option value="heat">heat</option>
        </select>
      </label>
      <label>p<sub>min</sub>:
        <input type="number" id="pmin" value="2" min="0" max="50" step="1" style="width:4.5rem">
      </label>
      <label>p<sub>max</sub>:
        <input type="number" id="pmax" value="98" min="50" max="100" step="1" style="width:4.5rem">
      </label>
      <button id="apply-style" class="btn btn-primary">Render raster</button>
    </div>

    <div class="ts" style="margin:.5rem 0 0">
      <strong>Time:</strong>
      <button id="play" class="btn">Play</button>
      <button id="pause" class="btn">Pause</button>
      <div class="grow">
        <input type="range" id="time" min="0" max="0" value="0" step="1" style="width:100%">
      </div>
      <div><span id="time-start">—</span> → <strong id="time-current">—</strong></div>
      <label><input type="checkbox" id="cumulate" checked> Cumulative</label>
    </div>

    <div id="map"></div>
  </section>

  <section class="card">
    <h2>Step 3 · Downloads</h2>
    <ul id="downloads"></ul>
  </section>

  <section class="card" id="stats-card" style="display:none">
    <h2>Step 4 · Velocity summary</h2>
    <div class="panel">
      <div class="vbox"><div class="chip">N: <span id="vel-n">—</span></div></div>
      <div class="vbox"><div class="chip">mean: <span id="vel-mean">—</span></div></div>
      <div class="vbox"><div class="chip">median: <span id="vel-med">—</span></div></div>
      <div class="vbox"><div class="chip">min: <span id="vel-min">—</span></div></div>
      <div class="vbox"><div class="chip">max: <span id="vel-max">—</span></div></div>
      <div class="vbox"><div class="chip">std: <span id="vel-std">—</span></div></div>
      <div class="vbox"><div class="chip">95% CI: <span id="vel-ci">—</span></div></div>
    </div>
    <div id="vel-chart-wrap">
      <canvas id="velChart"></canvas>
    </div>
  </section>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    // map and panes
    const map = L.map("map").setView([40, -3], 5);
    map.createPane("rasters");  map.getPane("rasters").style.zIndex = 300;
    map.createPane("vectors");  map.getPane("vectors").style.zIndex = 650;
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {attribution:"© OSM"}).addTo(map);

    const overlays = {};
    const layerControl = L.control.layers(null, overlays).addTo(map);
    const rasterOverlays = {};
    const rasterBounds = {};
    let vectorLayers = [];
    let currentRun = null;

    // CSV points + time slider
    const pointsGroup = L.layerGroup([], {pane:"vectors"}).addTo(map);
    overlays["CSV points"] = pointsGroup; layerControl.addOverlay(pointsGroup, "CSV points");
    let pointsAll = [];
    let timeDates = [];
    let timeIndexOf = {};
    let timeTimer = null;
    let dateKeyGlobal = null;

    // legend
    const legend = L.control({position:"bottomright"});
    legend.onAdd = function(){
      const div = L.DomUtil.create("div", "legend");
      div.innerHTML = `
        <div><strong>Legend</strong></div>
        <canvas id="leg-canvas" width="180" height="12"></canvas>
        <div class="ticks"><span id="leg-min">pmin</span><span id="leg-max">pmax</span></div>`;
      return div;
    };
    legend.addTo(map);

    function drawLegend(palette, vmin, vmax){
      const c = document.getElementById("leg-canvas"); if(!c) return;
      const ctx = c.getContext("2d");
      const grd = ctx.createLinearGradient(0, 0, c.width, 0);
      if (palette === "viridis"){
        [[0,[68,1,84]],[0.25,[59,82,139]],[0.5,[33,145,140]],[0.75,[94,201,98]],[1,[253,231,37]]]
          .forEach(([p,[r,g,b]]) => grd.addColorStop(p, `rgb(${r},${g},${b})`));
      } else if (palette === "heat"){
        [[0,[0,0,128]],[0.25,[0,255,255]],[0.5,[255,255,0]],[0.75,[255,128,0]],[1,[128,0,0]]]
          .forEach(([p,[r,g,b]]) => grd.addColorStop(p, `rgb(${r},${g},${b})`));
      } else { grd.addColorStop(0,"#000"); grd.addColorStop(1,"#fff"); }
      ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height);
      document.getElementById("leg-min").textContent = `pmin ${vmin}`;
      document.getElementById("leg-max").textContent = `pmax ${vmax}`;
    }

    // velocity summary + interactive histogram (Chart.js)
    let velChart = null;
    function fmt(x, d=3){ return (x==null || isNaN(x)) ? "—" : Number(x).toFixed(d); }
    function fmi(x){ return (x==null || isNaN(x)) ? "—" : String(Math.trunc(x)); }

    function renderVelocitySummary(stats){
      const card = document.getElementById("stats-card");
      if(!stats || !Number.isFinite(stats.count)){ card.style.display="none"; return; }
      card.style.display="";
      document.getElementById("vel-n").textContent   = fmi(stats.count);
      document.getElementById("vel-mean").textContent= fmt(stats.mean);
      document.getElementById("vel-med").textContent = fmt(stats.p50);
      document.getElementById("vel-min").textContent = fmt(stats.min);
      document.getElementById("vel-max").textContent = fmt(stats.max);
      document.getElementById("vel-std").textContent = fmt(stats.std);
      const ci = (stats.ci95_low!=null && stats.ci95_high!=null) ? `${fmt(stats.ci95_low)}–${fmt(stats.ci95_high)}` : "—";
      document.getElementById("vel-ci").textContent = ci;

      // build labels as bin ranges
      const bins = stats.hist_bins || [];
      const counts = stats.hist_counts || [];
      const labels = [];
      for (let i=0;i<Math.max(0, bins.length-1);i++){
        labels.push(`${fmt(bins[i],2)}–${fmt(bins[i+1],2)}`);
      }
      const data = counts.slice(0, labels.length);

      const ctx = document.getElementById("velChart").getContext("2d");
      if (velChart) velChart.destroy();
      velChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Velocity histogram',
            data,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { title: { display:true, text:'Velocity' }, ticks:{ maxRotation:0, autoSkip:true } },
            y: { title: { display:true, text:'Count' }, beginAtZero:true, precision:0 }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: (items)=> items.length? `Bin: ${labels[items[0].dataIndex]}` : '',
                label: (item)=> `Count: ${item.formattedValue}`
              }
            },
            legend: { display:false }
          }
        }
      });
    }

    // clear helpers
    function clearRasters(){
      Object.values(rasterOverlays).forEach(l=>{ try{ layerControl.removeLayer(l); map.removeLayer(l);}catch{} });
      for (const k of Object.keys(rasterOverlays)) delete rasterOverlays[k];
      for (const k of Object.keys(rasterBounds)) delete rasterBounds[k];
    }
    function clearVectors(){
      vectorLayers.forEach(l=>{ try{ layerControl.removeLayer(l); map.removeLayer(l);}catch{} });
      vectorLayers = [];
      pointsGroup.clearLayers();
      pointsAll = [];
      timeDates = []; timeIndexOf = {}; dateKeyGlobal = null;
      const slider = document.getElementById("time");
      slider.min=0; slider.max=0; slider.value=0; slider.disabled=true;
      document.getElementById("time-start").textContent = "—";
      document.getElementById("time-current").textContent = "—";
    }

    // add layers
    function addImage(name, url, bounds){
      const layer = L.imageOverlay(url, bounds, {opacity:0.85, pane:"rasters"});
      layer.addTo(map);
      rasterOverlays[name] = layer;
      rasterBounds[name] = bounds;
      overlays[name] = layer;
      layerControl.addOverlay(layer, name);
      try { map.fitBounds(layer.getBounds()); } catch {}
    }

    function detectDateKey(sampleProps){
      if (!sampleProps) return null;
      const keys = Object.keys(sampleProps);
      const cand = keys.find(k => /^(date_iso|date|fecha|datetime|fec)$/i.test(k));
      return cand || null;
    }
    function toISODate(s){
      if (!s && s!==0) return null;
      const d = new Date(s);
      if (!isNaN(d)) return d.toISOString().slice(0,10);
      // try plain YYYY-MM-DD
      const m = String(s).match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})/);
      if (m) {
        const mm = m[2].padStart(2,'0'), dd = m[3].padStart(2,'0');
        return `${m[1]}-${mm}-${dd}`;
      }
      return null;
    }

    async function addGeoJSON(name, url, kind){
      const gj = await fetch(url).then(r=>r.json());
      if (kind === "points"){
        pointsAll = Array.isArray(gj.features) ? gj.features : [];
        // robust date key detection
        const sample = pointsAll.find(f=>f && f.properties);
        dateKeyGlobal = detectDateKey(sample?.properties);
        // compute date array
        const dates = pointsAll
          .map(f => toISODate(f?.properties?.[dateKeyGlobal]))
          .filter(Boolean);
        const uq = Array.from(new Set(dates)).sort();
        timeDates = uq;
        timeIndexOf = Object.fromEntries(uq.map((d,i)=>[d,i]));
        const slider = document.getElementById("time");
        const tstart = document.getElementById("time-start");
        const tcur = document.getElementById("time-current");

        // if no time info, show ALL points and disable slider
        if (!uq.length){
          slider.disabled = true; slider.min=0; slider.max=0; slider.value=0;
          tstart.textContent = "—"; tcur.textContent = "—";
          pointsGroup.clearLayers();
          const layer = L.geoJSON(gj, {
            pane: "vectors",
            pointToLayer: (f, latlng) => L.circleMarker(latlng,{radius:4,color:"#0b5fff",weight:1,fillColor:"#7fa6ff",fillOpacity:0.8})
          }).addTo(pointsGroup);
          try{ map.fitBounds(layer.getBounds()); }catch{}
          return;
        }

        slider.min = 0; slider.max = uq.length - 1; slider.value = uq.length - 1; slider.disabled = false;
        tstart.textContent = uq[0]; tcur.textContent = uq[uq.length-1];
        renderPointsAt(parseInt(slider.value));
        return;
      }
      const opts = {
        pane: "vectors",
        style: (f) => {
          if (kind === "contours") return {color:"#0066cc", weight:1.5, opacity:0.9};
          if (kind === "ellipse")  return {color:"#aa8800", weight:2, fillColor:"#ffdd77", fillOpacity:0.25};
          return {color:"#d33", weight:1};
        },
        pointToLayer: (f, latlng) => L.circleMarker(latlng,{radius:4,color:"#d33",weight:1,fillColor:"#f88",fillOpacity:0.8})
      };
      const layer = L.geoJSON(gj, opts).addTo(map);
      vectorLayers.push(layer);
      overlays[name]=layer; layerControl.addOverlay(layer, name);
      try{ map.fitBounds(layer.getBounds()); }catch{}
    }

    function renderPointsAt(idx){
      const slider = document.getElementById("time");
      if (typeof idx !== "number") idx = parseInt(slider.value);
      const tcur = document.getElementById("time-current");
      if (!timeDates.length){ tcur.textContent = "—"; pointsGroup.clearLayers(); return; }
      const cutoff = timeDates[Math.max(0, Math.min(idx, timeDates.length-1))];
      tcur.textContent = cutoff;

      pointsGroup.clearLayers();
      const cum = document.getElementById("cumulate").checked;
      const feats = pointsAll.filter(f=>{
        const iso = toISODate(f?.properties?.[dateKeyGlobal]);
        if (!iso) return false;
        const i = timeIndexOf[iso];
        if (typeof i !== "number") return false;
        return cum ? (i <= idx) : (i === idx);
      });
      const layer = L.geoJSON({type:"FeatureCollection", features:feats}, {
        pane: "vectors",
        pointToLayer: (f, latlng) => L.circleMarker(latlng,{radius:4,color:"#0b5fff",weight:1,fillColor:"#7fa6ff",fillOpacity:0.8})
      });
      layer.addTo(pointsGroup);
      try{ map.fitBounds(pointsGroup.getBounds()); }catch{}
    }

    // time slider events
    document.getElementById("time").addEventListener("input", e => {
      renderPointsAt(parseInt(e.target.value));
    });
    document.getElementById("cumulate").addEventListener("change", () => {
      renderPointsAt();
    });
    document.getElementById("play").addEventListener("click", () => {
      if (timeTimer) return;
      const slider = document.getElementById("time");
      let i = parseInt(slider.value);
      timeTimer = setInterval(()=>{
        if (!timeDates.length){ clearInterval(timeTimer); timeTimer=null; return; }
        i = (i + 1 <= parseInt(slider.max)) ? i + 1 : 0;
        slider.value = i;
        renderPointsAt(i);
      }, 600);
    });
    document.getElementById("pause").addEventListener("click", () => {
      if (timeTimer){ clearInterval(timeTimer); timeTimer = null; }
    });

    // preview helpers
    function fillSelectOptions(select, headers, preferred){
      select.innerHTML = "";
      headers.forEach(h=>{ const opt = document.createElement("option"); opt.value = h; opt.textContent = h; select.appendChild(opt); });
      const idx = headers.findIndex(h => h.toLowerCase() === preferred);
      if(idx>=0) select.selectedIndex = idx;
    }
    function renderPreviewTable(headers, rows){
      const tbl = document.getElementById("preview-table");
      tbl.innerHTML = "";
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      headers.forEach(h=>{ const th=document.createElement("th"); th.textContent=h; trh.appendChild(th); });
      thead.appendChild(trh);
      const tbody = document.createElement("tbody");
      rows.slice(0,50).forEach(r=>{
        const tr = document.createElement("tr");
        headers.forEach(h=>{ const td=document.createElement("td"); td.textContent = r[h]; tr.appendChild(td); });
        tbody.appendChild(tr);
      });
      tbl.appendChild(thead); tbl.appendChild(tbody);
    }
    function currentSep(){ const v = document.getElementById("sep").value; return v === "\\t" ? "\t" : v; }

    // CSV preview toggle
    document.getElementById("toggle-preview").addEventListener("change", (e)=>{
      document.getElementById("preview-wrap").style.display = e.target.checked ? "" : "none";
      document.getElementById("preview-info").style.display = e.target.checked ? "" : "none";
    });

    document.getElementById("preview").onclick = async () => {
      const f = document.getElementById("csvfile").files[0];
      if(!f){ alert("Select a CSV"); return; }
      const sep = currentSep();
      Papa.parse(f, {
        delimiter: sep, header: true, dynamicTyping: false, preview: 200, skipEmptyLines: true,
        complete: res => {
          const data = res.data || [];
          if(!data.length){ alert("Empty CSV or wrong separator"); return; }
          const headers = res.meta.fields || Object.keys(data[0]);
          fillSelectOptions(document.getElementById("lon_field"), headers, "lon");
          fillSelectOptions(document.getElementById("lat_field"), headers, "lat");
          fillSelectOptions(document.getElementById("date_field"), headers, "date");
          fillSelectOptions(document.getElementById("id_field"), headers, "id");
          fillSelectOptions(document.getElementById("weight_field"), headers, "weight");
          fillSelectOptions(document.getElementById("case_field"), headers, "cases");
          renderPreviewTable(headers, data);
          const info = document.getElementById("preview-info");
          info.innerHTML = "";
          const chip = t => { const d=document.createElement("div"); d.className="chip"; d.textContent=t; return d; };
          info.appendChild(chip(`Rows (preview): ${data.length}`));
          info.appendChild(chip(`Separator: ${sep === "\t" ? "tab" : sep}`));
        }
      });
    };

    // apply raster styling
    function drawLegendFromInputs(){
      drawLegend(document.getElementById("palette").value,
                 document.getElementById("pmin").value,
                 document.getElementById("pmax").value);
    }
    document.getElementById("apply-style").onclick = async () => {
      const kind = document.getElementById("raster_layer").value;
      const pal  = document.getElementById("palette").value;
      const pmin = Number(document.getElementById("pmin").value);
      const pmax = Number(document.getElementById("pmax").value);
      if (!currentRun || !rasterOverlays[kind]) { alert("Run the process first and ensure the raster layer exists."); return; }
      const url = `/render?run_id=${encodeURIComponent(currentRun)}&kind=${encodeURIComponent(kind)}&palette=${encodeURIComponent(pal)}&pmin=${pmin}&pmax=${pmax}`;
      const resp = await fetch(url);
      const js = await resp.json();
      if (js.url){
        rasterOverlays[kind].setUrl(js.url);
        drawLegendFromInputs();
      }
    };

    // process
    document.getElementById("process").onclick = async () => {
      const f = document.getElementById("csvfile").files[0];
      if(!f){ alert("Select a CSV"); return; }

      const fd = new FormData();
      fd.append("csv_file", f);
      fd.append("grid", document.getElementById("grid").value || 12000);
      fd.append("cell", document.getElementById("cell").value || 1200);
      fd.append("contour", document.getElementById("contour").value || 30);
      fd.append("sep", document.getElementById("sep").value);
      fd.append("lon_field", document.getElementById("lon_field").value || "lon");
      fd.append("lat_field", document.getElementById("lat_field").value || "lat");
      fd.append("date_field", document.getElementById("date_field").value || "date");
      fd.append("id_field", document.getElementById("id_field").value || "id");
      fd.append("weight_field", document.getElementById("weight_field").value || "weight");
      fd.append("case_field", document.getElementById("case_field").value || "cases");

      const r = await fetch("/run", { method:"POST", body:fd });
      const js = await r.json();
      currentRun = js.run_id;

      const ul = document.getElementById("downloads");
      ul.innerHTML="";
      for (const [k,v] of Object.entries(js.urls)) {
        if (v) {
          const li = document.createElement("li");
          li.innerHTML = `<a href="${v}" target="_blank" rel="noopener">${k}</a>`;
          ul.appendChild(li);
        }
      }

      renderVelocitySummary(js?.stats?.velocity);

      clearRasters(); clearVectors();
      if (js.images?.kriging)  addImage("kriging",  js.images.kriging.url,  js.images.kriging.bounds);
      if (js.images?.slope)    addImage("slope",    js.images.slope.url,    js.images.slope.bounds);
      if (js.images?.velocity) addImage("velocity", js.images.velocity.url, js.images.velocity.bounds);

      if (js.urls.contours_geojson)  await addGeoJSON("contours", js.urls.contours_geojson, "contours");
      if (js.urls.ellipse_geojson)   await addGeoJSON("ellipse",  js.urls.ellipse_geojson,  "ellipse");
      if (js.urls.all_points_geojson)await addGeoJSON("CSV points", js.urls.all_points_geojson, "points");

      drawLegendFromInputs();
    };
  </script>
</body>
</html>
