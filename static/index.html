<!-- static/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FrontWave - Viewer</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root { --primary:#0b5fff; --primary-ink:#fff; --muted:#555; }
    body { margin:0; font-family:sans-serif }
    header { background:#333; color:#fff; padding:1rem }
    section.card { margin:1rem; padding:1rem; border:1px solid #ccc; border-radius:8px }
    .row { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center }
    label { font-size:0.9rem }
    select, input[type="number"], input[type="range"] { padding:0.3rem }
    .muted { color:var(--muted); font-size:0.9em }
    #map { height:560px; margin:1rem 0 }
    .table-wrap { overflow:auto; max-height:260px; border:1px solid #ddd }
    table { border-collapse:collapse; width:100% }
    th, td { border:1px solid #ddd; padding:4px 6px; font-size:12px; white-space:nowrap }
    th { background:#f5f5f5; position:sticky; top:0 }
    .chips { display:flex; flex-wrap:wrap; gap:0.5rem; margin:0.5rem 0 }
    .chip { background:#eee; padding:0.4rem 0.8rem; border-radius:18px }
    .legend { background:#fff; padding:.6rem; border:1px solid #ccc; border-radius:6px; line-height:1.1 }
    .legend canvas { display:block; width:180px; height:12px; image-rendering:pixelated; margin:.25rem 0 }
    .legend .ticks { display:flex; justify-content:space-between; font-size:.8rem }
    .ts { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap }
    .ts .grow { flex:1 1 260px }
    .btn { padding:.5rem .9rem; border:1px solid #aaa; background:#f8f8f8; border-radius:8px; cursor:pointer; font-weight:600 }
    .btn-primary { background:var(--primary); color:var(--primary-ink); border-color:var(--primary) }
    .panel { display:flex; gap:1rem; align-items:center; flex-wrap:wrap }
    .vbox { display:flex; gap:.4rem; align-items:center }
    #vel-chart { width:260px; height:70px; border:1px solid #ddd; border-radius:4px; background:#fff }
  </style>
</head>
<body>
  <header>
    <h1>FrontWave Tool</h1>
    <h3>Interpolation and velocity with quick stats</h3>
    <p class="muted">1) Load CSV → 2) Check separator and fields → 3) Process → 4) Map and downloads</p>
  </header>

  <section class="card">
    <h2>Step 1 · Load CSV</h2>
    <div class="row">
      <input type="file" id="csvfile" accept=".csv" />
      <label>Separator:
        <select id="sep">
          <option value=";">; (semicolon)</option>
          <option value=",">, (comma)</option>
          <option value="\\t">tab</option>
          <option value="|">| (pipe)</option>
        </select>
      </label>
      <label><input type="checkbox" id="toggle-preview"> Show CSV preview</label>
      <button id="preview" class="btn">Preview</button>
      <button id="process" class="btn btn-primary">Process</button>
    </div>
    <div class="row" style="margin-top:.5rem">
      <label>lon: <select id="lon_field"></select></label>
      <label>lat: <select id="lat_field"></select></label>
      <label>date: <select id="date_field"></select></label>
      <label>id: <select id="id_field"></select></label>
      <label>weight: <select id="weight_field"></select></label>
      <label>cases: <select id="case_field"></select></label>
      <label>grid (m): <input type="number" id="grid" value="12000" style="width:7rem"></label>
      <label>cell (m): <input type="number" id="cell" value="1200" style="width:7rem"></label>
      <label>contour: <input type="number" id="contour" value="30" style="width:6rem"></label>
    </div>
    <div class="table-wrap" id="preview-wrap" style="display:none">
      <table id="preview-table"></table>
    </div>
    <div class="chips" id="preview-info" style="display:none"></div>
  </section>

  <section class="card">
    <h2>Step 2 · Map</h2>

    <div class="row" style="align-items:flex-end">
      <label>Raster layer:
        <select id="raster_layer">
          <option value="velocity">velocity</option>
          <option value="kriging">kriging</option>
          <option value="slope">slope</option>
        </select>
      </label>
      <label>Palette:
        <select id="palette">
          <option value="gray">gray</option>
          <option value="viridis">viridis</option>
          <option value="heat">heat</option>
        </select>
      </label>
      <label>p<sub>min</sub>:
        <input type="number" id="pmin" value="2" min="0" max="50" step="1" style="width:4.5rem">
      </label>
      <label>p<sub>max</sub>:
        <input type="number" id="pmax" value="98" min="50" max="100" step="1" style="width:4.5rem">
      </label>
      <button id="apply-style" class="btn btn-primary">Render raster</button>
    </div>

    <div class="ts" style="margin:.5rem 0 0">
      <strong>Time:</strong>
      <button id="play" class="btn">Play</button>
      <button id="pause" class="btn">Pause</button>
      <div class="grow">
        <input type="range" id="time" min="0" max="0" value="0" step="1" style="width:100%">
      </div>
      <div><span id="time-start">—</span> → <strong id="time-current">—</strong></div>
    </div>

    <div id="map"></div>
  </section>

  <section class="card">
    <h2>Step 3 · Downloads</h2>
    <ul id="downloads"></ul>
  </section>

  <section class="card" id="stats-card" style="display:none">
    <h2>Step 4 · Velocity summary</h2>
    <div class="panel">
      <div class="vbox"><div class="chip">N: <span id="vel-n">—</span></div></div>
      <div class="vbox"><div class="chip">mean: <span id="vel-mean">—</span></div></div>
      <div class="vbox"><div class="chip">median: <span id="vel-med">—</span></div></div>
      <div class="vbox"><div class="chip">min: <span id="vel-min">—</span></div></div>
      <div class="vbox"><div class="chip">max: <span id="vel-max">—</span></div></div>
      <div class="vbox"><div class="chip">std: <span id="vel-std">—</span></div></div>
      <div class="vbox"><div class="chip">95% CI: <span id="vel-ci">—</span></div></div>
      <canvas id="vel-chart"></canvas>
    </div>
  </section>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // map and panes
    const map = L.map("map").setView([40, -3], 5);
    map.createPane("rasters");  map.getPane("rasters").style.zIndex = 300;
    map.createPane("vectors");  map.getPane("vectors").style.zIndex = 650;
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {attribution:"© OSM"}).addTo(map);

    const overlays = {};
    const layerControl = L.control.layers(null, overlays).addTo(map);
    const rasterOverlays = {};
    const rasterBounds = {};
    let vectorLayers = [];
    let currentRun = null;

    // persistent group for CSV points with time slider
    const pointsGroup = L.layerGroup([], {pane:"vectors"}).addTo(map);
    overlays["CSV points"] = pointsGroup; layerControl.addOverlay(pointsGroup, "CSV points");
    let pointsAll = [];        // all features from CSV
    let timeDates = [];        // unique sorted dates (ISO)
    let timeIndexOf = {};      // ISO -> idx
    let timeTimer = null;

    // legend
    const legend = L.control({position:"bottomright"});
    legend.onAdd = function(){
      const div = L.DomUtil.create("div", "legend");
      div.innerHTML = `
        <div><strong>Legend</strong></div>
        <canvas id="leg-canvas" width="180" height="12"></canvas>
        <div class="ticks"><span id="leg-min">pmin</span><span id="leg-max">pmax</span></div>`;
      return div;
    };
    legend.addTo(map);

    function drawLegend(palette, vmin, vmax){
      const c = document.getElementById("leg-canvas"); if(!c) return;
      const ctx = c.getContext("2d");
      const grd = ctx.createLinearGradient(0, 0, c.width, 0);
      if (palette === "viridis"){
        [[0,[68,1,84]],[0.25,[59,82,139]],[0.5,[33,145,140]],[0.75,[94,201,98]],[1,[253,231,37]]]
          .forEach(([p,[r,g,b]]) => grd.addColorStop(p, `rgb(${r},${g},${b})`));
      } else if (palette === "heat"){
        [[0,[0,0,128]],[0.25,[0,255,255]],[0.5,[255,255,0]],[0.75,[255,128,0]],[1,[128,0,0]]]
          .forEach(([p,[r,g,b]]) => grd.addColorStop(p, `rgb(${r},${g},${b})`));
      } else { grd.addColorStop(0,"#000"); grd.addColorStop(1,"#fff"); }
      ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height);
      document.getElementById("leg-min").textContent = `pmin ${vmin}`;
      document.getElementById("leg-max").textContent = `pmax ${vmax}`;
    }

    // velocity summary
    function fmt(x, d=3){ return (x==null || isNaN(x)) ? "—" : Number(x).toFixed(d); }
    function fmi(x){ return (x==null || isNaN(x)) ? "—" : String(Math.trunc(x)); }

    function drawVelocityChart(bins, counts){
      const canvas = document.getElementById("vel-chart"); if(!canvas) return;
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      if (!bins || !counts || !counts.length) { ctx.fillStyle="#999"; ctx.fillText("no data", 8, 16); return; }
      const maxc = Math.max(...counts);
      const barW = Math.max(1, Math.floor((w-10) / counts.length));
      ctx.fillStyle = "#0b5fff";
      for (let i=0;i<counts.length;i++){
        const x = 5 + i*barW;
        const bh = Math.round(((counts[i]||0)/maxc) * (h-10));
        ctx.fillRect(x, h-5-bh, barW-2, bh);
      }
      ctx.strokeStyle="#ccc"; ctx.strokeRect(0.5,0.5,w-1,h-1);
    }

    function renderVelocitySummary(stats){
      const card = document.getElementById("stats-card");
      if(!stats || !Number.isFinite(stats.count)){ card.style.display="none"; return; }
      card.style.display="";
      document.getElementById("vel-n").textContent   = fmi(stats.count);
      document.getElementById("vel-mean").textContent= fmt(stats.mean);
      document.getElementById("vel-med").textContent = fmt(stats.p50);
      document.getElementById("vel-min").textContent = fmt(stats.min);
      document.getElementById("vel-max").textContent = fmt(stats.max);
      document.getElementById("vel-std").textContent = fmt(stats.std);
      const ci = (stats.ci95_low!=null && stats.ci95_high!=null) ? `${fmt(stats.ci95_low)}–${fmt(stats.ci95_high)}` : "—";
      document.getElementById("vel-ci").textContent = ci;
      drawVelocityChart(stats.hist_bins, stats.hist_counts);
    }

    // clear helpers
    function clearRasters(){
      Object.values(rasterOverlays).forEach(l=>{ try{ layerControl.removeLayer(l); map.removeLayer(l);}catch{} });
      for (const k of Object.keys(rasterOverlays)) delete rasterOverlays[k];
      for (const k of Object.keys(rasterBounds)) delete rasterBounds[k];
    }
    function clearVectors(){
      vectorLayers.forEach(l=>{ try{ layerControl.removeLayer(l); map.removeLayer(l);}catch{} });
      vectorLayers = [];
      pointsGroup.clearLayers();
      pointsAll = [];
      timeDates = []; timeIndexOf = {};
    }

    // add layers
    function addImage(name, url, bounds){
      const layer = L.imageOverlay(url, bounds, {opacity:0.85, pane:"rasters"});
      layer.addTo(map);
      rasterOverlays[name] = layer;
      rasterBounds[name] = bounds;
      overlays[name] = layer;
      layerControl.addOverlay(layer, name);
      try { map.fitBounds(layer.getBounds()); } catch {}
    }

    async function addGeoJSON(name, url, kind){
      const gj = await fetch(url).then(r=>r.json());
      if (kind === "points"){
        pointsAll = Array.isArray(gj.features) ? gj.features : [];
        const sample = pointsAll.find(f=>f && f.properties);
        const dateKey = sample && ("DATE_ISO" in sample.properties ? "DATE_ISO" :
                                   ("date" in sample.properties ? "date" : null));
        const dates = pointsAll
          .map(f => (dateKey ? String(f.properties[dateKey]) : null))
          .filter(s => s && !isNaN(new Date(s)))
          .map(s => s.slice(0,10));
        const uq = Array.from(new Set(dates)).sort();
        timeDates = uq;
        timeIndexOf = Object.fromEntries(uq.map((d,i)=>[d,i]));
        const slider = document.getElementById("time");
        const tstart = document.getElementById("time-start");
        const tcur = document.getElementById("time-current");
        if (uq.length){
          slider.min = 0; slider.max = uq.length - 1; slider.value = uq.length - 1; slider.disabled = false;
          tstart.textContent = uq[0]; tcur.textContent = uq[uq.length-1];
          renderPointsAt(parseInt(slider.value), dateKey);
        } else {
          slider.min = 0; slider.max = 0; slider.value = 0; slider.disabled = true;
          tstart.textContent = "—"; tcur.textContent = "—";
          pointsGroup.clearLayers();
        }
        return;
      }
      const opts = {
        pane: "vectors",
        style: (f) => {
          if (kind === "contours") return {color:"#0066cc", weight:1.5, opacity:0.9};
          if (kind === "ellipse")  return {color:"#aa8800", weight:2, fillColor:"#ffdd77", fillOpacity:0.25};
          return {color:"#d33", weight:1};
        },
        pointToLayer: (f, latlng) => L.circleMarker(latlng,{radius:4,color:"#d33",weight:1,fillColor:"#f88",fillOpacity:0.8})
      };
      const layer = L.geoJSON(gj, opts).addTo(map);
      vectorLayers.push(layer);
      overlays[name]=layer; layerControl.addOverlay(layer, name);
      try{ map.fitBounds(layer.getBounds()); }catch{}
    }

    function renderPointsAt(idx, dateKeyGuess){
      const slider = document.getElementById("time");
      if (typeof idx !== "number") idx = parseInt(slider.value);
      const tcur = document.getElementById("time-current");
      if (!timeDates.length){ tcur.textContent = "—"; pointsGroup.clearLayers(); return; }
      const cutoff = timeDates[Math.max(0, Math.min(idx, timeDates.length-1))];
      tcur.textContent = cutoff;
      pointsGroup.clearLayers();
      const dateKey = dateKeyGuess || (pointsAll[0]?.properties?.DATE_ISO ? "DATE_ISO" : "date");
      const layer = L.geoJSON({
        type:"FeatureCollection",
        features: pointsAll.filter(f=>{
          const s = f.properties?.[dateKey]; if (!s) return false;
          const d = String(s).slice(0,10);
          const i = timeIndexOf[d]; return typeof i === "number" && i <= idx;
        })
      }, {
        pane: "vectors",
        pointToLayer: (f, latlng) => L.circleMarker(latlng,{radius:4,color:"#0b5fff",weight:1,fillColor:"#7fa6ff",fillOpacity:0.8})
      });
      layer.addTo(pointsGroup);
      try{ map.fitBounds(pointsGroup.getBounds()); }catch{}
    }

    // time slider events
    document.getElementById("time").addEventListener("input", e => {
      renderPointsAt(parseInt(e.target.value));
    });
    document.getElementById("play").addEventListener("click", () => {
      if (timeTimer) return;
      const slider = document.getElementById("time");
      let i = parseInt(slider.value);
      timeTimer = setInterval(()=>{
        if (!timeDates.length){ clearInterval(timeTimer); timeTimer=null; return; }
        i = (i + 1 <= parseInt(slider.max)) ? i + 1 : 0;
        slider.value = i;
        renderPointsAt(i);
      }, 600);
    });
    document.getElementById("pause").addEventListener("click", () => {
      if (timeTimer){ clearInterval(timeTimer); timeTimer = null; }
    });

    // preview helpers
    function fillSelectOptions(select, headers, preferred){
      select.innerHTML = "";
      headers.forEach(h=>{ const opt = document.createElement("option"); opt.value = h; opt.textContent = h; select.appendChild(opt); });
      const idx = headers.findIndex(h => h.toLowerCase() === preferred);
      if(idx>=0) select.selectedIndex = idx;
    }
    function renderPreviewTable(headers, rows){
      const tbl = document.getElementById("preview-table");
      tbl.innerHTML = "";
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      headers.forEach(h=>{ const th=document.createElement("th"); th.textContent=h; trh.appendChild(th); });
      thead.appendChild(trh);
      const tbody = document.createElement("tbody");
      rows.slice(0,50).forEach(r=>{
        const tr = document.createElement("tr");
        headers.forEach(h=>{ const td=document.createElement("td"); td.textContent = r[h]; tr.appendChild(td); });
        tbody.appendChild(tr);
      });
      tbl.appendChild(thead); tbl.appendChild(tbody);
    }
    function currentSep(){ const v = document.getElementById("sep").value; return v === "\\t" ? "\t" : v; }

    // CSV preview toggle
    document.getElementById("toggle-preview").addEventListener("change", (e)=>{
      document.getElementById("preview-wrap").style.display = e.target.checked ? "" : "none";
      document.getElementById("preview-info").style.display = e.target.checked ? "" : "none";
    });

    document.getElementById("preview").onclick = async () => {
      const f = document.getElementById("csvfile").files[0];
      if(!f){ alert("Select a CSV"); return; }
      const sep = currentSep();
      Papa.parse(f, {
        delimiter: sep, header: true, dynamicTyping: false, preview: 200, skipEmptyLines: true,
        complete: res => {
          const data = res.data || [];
          if(!data.length){ alert("Empty CSV or wrong separator"); return; }
          const headers = res.meta.fields || Object.keys(data[0]);
          fillSelectOptions(document.getElementById("lon_field"), headers, "lon");
          fillSelectOptions(document.getElementById("lat_field"), headers, "lat");
          fillSelectOptions(document.getElementById("date_field"), headers, "date");
          fillSelectOptions(document.getElementById("id_field"), headers, "id");
          fillSelectOptions(document.getElementById("weight_field"), headers, "weight");
          fillSelectOptions(document.getElementById("case_field"), headers, "cases");
          renderPreviewTable(headers, data);
          const info = document.getElementById("preview-info");
          info.innerHTML = "";
          const chip = t => { const d=document.createElement("div"); d.className="chip"; d.textContent=t; return d; };
          info.appendChild(chip(`Rows (preview): ${data.length}`));
          info.appendChild(chip(`Separator: ${sep === "\t" ? "tab" : sep}`));
        }
      });
    };

    // apply raster styling
    document.getElementById("apply-style").onclick = async () => {
      const kind = document.getElementById("raster_layer").value;
      const pal  = document.getElementById("palette").value;
      const pmin = Number(document.getElementById("pmin").value);
      const pmax = Number(document.getElementById("pmax").value);
      if (!currentRun || !rasterOverlays[kind]) { alert("Run the process first and ensure the raster layer exists."); return; }
      const url = `/render?run_id=${encodeURIComponent(currentRun)}&kind=${encodeURIComponent(kind)}&palette=${encodeURIComponent(pal)}&pmin=${pmin}&pmax=${pmax}`;
      const resp = await fetch(url);
      const js = await resp.json();
      if (js.url){
        rasterOverlays[kind].setUrl(js.url);
        drawLegend(pal, pmin, pmax);
      }
    };

    // process
    document.getElementById("process").onclick = async () => {
      const f = document.getElementById("csvfile").files[0];
      if(!f){ alert("Select a CSV"); return; }

      const fd = new FormData();
      fd.append("csv_file", f);
      fd.append("grid", document.getElementById("grid").value || 12000);
      fd.append("cell", document.getElementById("cell").value || 1200);
      fd.append("contour", document.getElementById("contour").value || 30);
      fd.append("sep", document.getElementById("sep").value);
      fd.append("lon_field", document.getElementById("lon_field").value || "lon");
      fd.append("lat_field", document.getElementById("lat_field").value || "lat");
      fd.append("date_field", document.getElementById("date_field").value || "date");
      fd.append("id_field", document.getElementById("id_field").value || "id");
      fd.append("weight_field", document.getElementById("weight_field").value || "weight");
      fd.append("case_field", document.getElementById("case_field").value || "cases");

      const r = await fetch("/run", { method:"POST", body:fd });
      const js = await r.json();
      currentRun = js.run_id;

      const ul = document.getElementById("downloads");
      ul.innerHTML="";
      for (const [k,v] of Object.entries(js.urls)) {
        if (v) {
          const li = document.createElement("li");
          li.innerHTML = `<a href="${v}" target="_blank" rel="noopener">${k}</a>`;
          ul.appendChild(li);
        }
      }

      renderVelocitySummary(js?.stats?.velocity);

      clearRasters(); clearVectors();
      if (js.images?.kriging)  addImage("kriging",  js.images.kriging.url,  js.images.kriging.bounds);
      if (js.images?.slope)    addImage("slope",    js.images.slope.url,    js.images.slope.bounds);
      if (js.images?.velocity) addImage("velocity", js.images.velocity.url, js.images.velocity.bounds);

      if (js.urls.contours_geojson)  await addGeoJSON("contours", js.urls.contours_geojson, "contours");
      if (js.urls.ellipse_geojson)   await addGeoJSON("ellipse",  js.urls.ellipse_geojson,  "ellipse");
      if (js.urls.all_points_geojson)await addGeoJSON("CSV points", js.urls.all_points_geojson, "points");

      drawLegend(document.getElementById("palette").value,
                 document.getElementById("pmin").value,
                 document.getElementById("pmax").value);
    };
  </script>
</body>
</html>
