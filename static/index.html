<!-- static/index.html (full file) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FrontWave - Viewer</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root { --primary:#0b5fff; --ink:#fff; --muted:#666; --panel:#f7f9fc; --panel2:#eef3ff; }
    * { box-sizing:border-box }
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:#111 }
    header { background:#222; color:#fff; padding:1rem 1.25rem }
    header h1 { margin:0 0 .25rem; font-size:1.4rem }
    header h3 { margin:.1rem 0 .25rem; font-weight:500; color:#cfcfcf }
    header p { margin:0; color:#b7b7b7; font-size:.9rem }

    section.card { margin:1rem; padding:1rem; border:1px solid #ddd; border-radius:10px; background:#fff }
    h2 { margin:.25rem 0 .75rem; font-size:1.2rem }
    .row { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center }
    .col { display:flex; flex-direction:column; gap:.5rem }
    label { font-size:.95rem }
    select, input[type="number"], input[type="text"], input[type="range"], input[type="color"] { padding:.35rem .45rem; border:1px solid #bbb; border-radius:8px; }
    .muted { color:var(--muted) }
    .center { display:flex; justify-content:center; align-items:center; }

    .btn { padding:.6rem 1rem; border:1px solid #aaa; background:#f7f7f7; border-radius:10px; cursor:pointer; font-weight:700 }
    .btn-primary { background:var(--primary); color:var(--ink); border-color:var(--primary) }
    .btn:disabled { opacity:.6; cursor:not-allowed }

    #map { height:560px; margin:1rem 0; border:1px solid #ddd; border-radius:10px }

    .table-wrap { overflow:auto; max-height:260px; border:1px solid #ddd; border-radius:8px; }
    table { border-collapse:collapse; width:100% }
    th, td { border:1px solid #eee; padding:4px 6px; font-size:12px; white-space:nowrap }
    th { background:#fafafa; position:sticky; top:0 }

    .chips { display:flex; flex-wrap:wrap; gap:.5rem; }
    .chip { background:#f0f0f0; padding:.35rem .7rem; border-radius:999px; font-size:.9rem }

    .leaflet-control-layers { max-height:550px; overflow:auto }
    .leaflet-control-layers-toggle { display:none }
    .leaflet-control-layers-expanded { display:block; padding:.5rem .5rem .25rem .5rem; background:#fff; border:1px solid rgba(0,0,0,.25) }
    .layers-title { font-weight:700; margin:.35rem 0 .25rem; }

    .leg-panel { background:#fff; border:1px solid #ccc; border-radius:8px; padding:.6rem; width:260px; max-height:320px; overflow:auto }
    .leg-item { margin:.45rem 0; }
    .leg-head { display:flex; align-items:center; justify-content:space-between; gap:.5rem; font-size:.9rem }
    .leg-grad { display:block; width:100%; height:12px; image-rendering:pixelated; border-radius:3px; border:1px solid #ddd; cursor:pointer; margin:.35rem 0 }
    .leg-meta { font-size:.8rem; color:#444; display:flex; justify-content:space-between }

    #vel-chart-wrap { width:820px; max-width:100%; height:380px; background:#fff; border:1px solid #ddd; border-radius:10px; padding:.5rem; }
    .panel { display:flex; gap:1rem; align-items:center; flex-wrap:wrap; margin:.5rem 0 }
    .grow { flex:1 1 280px }
    .kpanel { border:1px dashed #ccc; padding:.75rem; border-radius:8px }

    #toolbox-toggle { position:fixed; right:10px; top:50%; transform:translateY(-50%); z-index:1000; padding:.5rem .75rem; border-radius:10px; border:1px solid #bbb; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,.08) }
    #toolbox { position:fixed; right:0; top:0; bottom:0; width:360px; background:var(--panel); border-left:1px solid #cfd8ea; box-shadow: -6px 0 16px rgba(0,0,0,.08); z-index:999; transform:translateX(100%); transition:transform .25s ease; display:flex; flex-direction:column }
    #toolbox.open { transform:translateX(0) }
    .tb-head { display:flex; align-items:center; justify-content:space-between; padding:.75rem .9rem; border-bottom:1px solid #dfe6f5; background:#fff }
    .tb-body { padding:.8rem .9rem; overflow:auto }
    .tb-sec { background:#fff; border:1px solid #dfe6f5; border-radius:10px; padding:.7rem .75rem; margin-bottom:.75rem }
    .tb-sec h4 { margin:.1rem 0 .5rem; font-size:1rem }
    .tb-subtle { background:var(--panel2); border-color:#d0defe }
    .tb-note { font-size:.85rem; color:#444; margin:.25rem 0 .5rem }

    .timebar { display:flex; align-items:center; gap:.6rem; flex-wrap:wrap }
    .time-current { font-size:1.15rem; font-weight:800; background:#eef3ff; border:1px solid #cfe0ff; padding:.2rem .5rem; border-radius:8px; }
    .time-range { color:#333; font-weight:600 }
  </style>
</head>
<body>
  <header>
    <h1>FrontWave Tool</h1>
    <h3>Interpolation and velocity with quick stats</h3>
    <p>1) Load CSV → 2) Set fields and kriging params → 3) Process → 4) Map, legends, and downloads</p>
  </header>

  <section class="card">
    <h2>Step 1 · Prepare input</h2>

    <div class="card" style="margin:0 0 1rem 0">
      <h3 style="margin:.25rem 0 .6rem">1) Load CSV and preview</h3>
      <div class="row">
        <input type="file" id="csvfile" accept=".csv" />
        <label>Separator
          <select id="sep">
            <option value=";">; (semicolon)</option>
            <option value=",">, (comma)</option>
            <option value="\\t">tab</option>
            <option value="|">| (pipe)</option>
          </select>
        </label>
        <button id="preview" class="btn">Preview</button>
        <button id="close-preview" class="btn">Close preview</button>
      </div>
      <div class="table-wrap" id="preview-wrap" style="display:none">
        <table id="preview-table"></table>
      </div>
      <div class="chips" id="preview-info" style="display:none"></div>
    </div>

    <div class="card" style="margin:0 0 1rem 0">
      <h3 style="margin:.25rem 0 .6rem">2) Select fields</h3>
      <div class="row">
        <label>Longitude field (X)
          <select id="lon_field"></select>
        </label>
        <label>Latitude field (Y)
          <select id="lat_field"></select>
        </label>
        <label>Date field
          <select id="date_field"></select>
        </label>
        <label>Identifier field
          <select id="id_field"></select>
        </label>
        <label>Weight field
          <select id="weight_field"></select>
        </label>
      </div>
    </div>

    <div class="card" style="margin:0 0 1rem 0">
      <h3 style="margin:.25rem 0 .6rem">3) Kriging parameters</h3>
      <div class="row kpanel">
        <label>Model
          <select id="kriging_model">
            <option value="ordinary">Ordinary Kriging</option>
            <option value="universal">Universal Kriging</option>
          </select>
        </label>
        <label>Variogram
          <select id="variogram_model">
            <option value="spherical">spherical</option>
            <option value="exponential">exponential</option>
            <option value="gaussian">gaussian</option>
            <option value="linear">linear</option>
            <option value="power">power</option>
          </select>
        </label>
        <label>Sill <input type="number" id="var_sill" placeholder="auto" step="any" style="width:7rem"></label>
        <label>Range <input type="number" id="var_range" placeholder="auto" step="any" style="width:7rem"></label>
        <label>Nugget <input type="number" id="var_nugget" placeholder="auto" step="any" style="width:7rem"></label>
        <label># lags <input type="number" id="nlags" value="6" min="2" max="48" style="width:6rem"></label>
        <label><input type="checkbox" id="use_weights"> Weighted</label>
      </div>
    </div>

    <div class="card" style="margin:0 0 1rem 0">
      <h3 style="margin:.25rem 0 .6rem">4) Cell size, grid size, and contour</h3>
      <div class="row">
        <label>Grid size (m)
          <input type="number" id="grid" value="12000" style="width:7rem">
        </label>
        <label>Kriging cell (m)
          <input type="number" id="cell" value="1200" style="width:7rem">
        </label>
        <label>Contour interval
          <input type="number" id="contour" value="30" style="width:6rem">
        </label>
      </div>
    </div>

    <div class="center">
      <button id="process" class="btn btn-primary">Process</button>
    </div>
  </section>

  <section class="card">
    <h2>Step 2 · Map</h2>
    <div class="row" style="align-items:center">
      <label>Map height
        <input type="range" id="map_h" min="360" max="1000" step="20" value="560">
      </label>
      <button id="map_max" class="btn">Maximize</button>
      <span class="muted">Open the right “Tools” tab to style layers and control time.</span>
    </div>
    <div id="map"></div>
  </section>

  <section class="card">
    <h2>Step 3 · Downloads</h2>
    <div class="chips" id="bundle-chip" style="display:none"></div>
    <details open>
      <summary>Advanced downloads</summary>
      <ul id="downloads"></ul>
    </details>
  </section>

  <section class="card" id="stats-card" style="display:none">
    <h2>Step 4 · Velocity summary</h2>
    <div class="panel">
      <div class="chip">N: <span id="vel-n">—</span></div>
      <div class="chip">mean: <span id="vel-mean">—</span></div>
      <div class="chip">median: <span id="vel-med">—</span></div>
      <div class="chip">min: <span id="vel-min">—</span></div>
      <div class="chip">max: <span id="vel-max">—</span></div>
      <div class="chip">std: <span id="vel-std">—</span></div>
      <div class="chip">95% CI: <span id="vel-ci">—</span></div>

      <div class="row" style="align-items:center">
        <strong>Bins:</strong>
        <button id="bins_minus" class="btn">−</button>
        <input type="range" id="bins_slider" min="6" max="48" step="1" value="24" list="bins_ticks">
        <button id="bins_plus" class="btn">+</button>
        <span id="bins_label" class="chip">24</span>
        <label><input type="checkbox" id="show_cdf"> Show CDF</label>
        <button id="hist-copy" class="btn">Copy image</button>
        <button id="hist-save" class="btn">Save PNG</button>
      </div>
      <datalist id="bins_ticks">
        <option value="6"></option>
        <option value="12"></option>
        <option value="24"></option>
        <option value="36"></option>
        <option value="48"></option>
      </datalist>
    </div>
    <div id="vel-chart-wrap"><canvas id="velChart"></canvas></div>
    <p class="muted" style="margin-top:.5rem">
      Shaded band shows mean ± 1 SD. Solid line = mean. Dashed = median.
    </p>
  </section>

  <section class="card">
    <h2>Execution log</h2>
    <div id="run-log" class="row" style="gap:.75rem"></div>
  </section>

  <!-- Toolbox -->
  <button id="toolbox-toggle" aria-controls="toolbox" aria-expanded="false">Tools</button>
  <aside id="toolbox" class="closed" aria-label="Widget manager">
    <div class="tb-head">
      <strong>Tools</strong>
      <button id="toolbox-close" class="btn">Close</button>
    </div>
    <div class="tb-body">
      <div class="tb-sec tb-subtle">
        <h4>Panels visibility</h4>
        <div class="row">
          <label><input type="checkbox" id="show_layerctl" checked> Show layer control</label>
          <label><input type="checkbox" id="show_legend" checked> Show legend</label>
        </div>
      </div>

      <div class="tb-sec tb-subtle">
        <h4>Layer symbology</h4>
        <div class="tb-note">Raster and points are controlled independently.</div>
        <div class="row" style="align-items:flex-end">
          <label>Raster layer
            <select id="raster_layer"></select>
          </label>
          <label>Palette
            <select id="palette">
              <option>gray</option><option>viridis</option><option>plasma</option><option>magma</option>
              <option>inferno</option><option>cividis</option><option>terrain</option><option>turbo</option>
              <option>coolwarm</option><option>heat</option>
            </select>
          </label>
          <label>Opacity
            <input type="range" id="raster_opacity" min="0.1" max="1" step="0.05" value="0.85">
          </label>
          <button id="apply-style" class="btn btn-primary">Render raster</button>
        </div>
      </div>

      <div class="tb-sec">
        <h4>Point symbology</h4>
        <div class="row" style="align-items:flex-end">
          <label>Fill <input type="color" id="pt_color" value="#7fa6ff"></label>
          <label>Stroke <input type="color" id="pt_stroke" value="#0b5fff"></label>
          <label>Size <input type="number" id="pt_size" value="4" min="1" max="20" style="width:4.5rem"></label>
          <label>Opacity <input type="range" id="pt_opacity" value="0.85" min="0.1" max="1" step="0.05" style="width:120px"></label>
          <button id="apply-pts-style" class="btn">Apply</button>
        </div>
      </div>

      <div class="tb-sec tb-subtle">
        <h4>Time control</h4>
        <div class="timebar">
          <div class="time-range">Range: <span id="time-start">—</span> → <span id="time-end">—</span></div>
          <div class="time-current">Current: <span id="time-current">—</span></div>
        </div>
        <div class="row" style="align-items:center; margin-top:.4rem">
          <button id="play" class="btn">Play</button>
          <button id="pause" class="btn">Pause</button>
          <div class="grow"><input type="range" id="time" min="0" max="0" value="0" step="1" style="width:100%"></div>
          <label><input type="checkbox" id="cumulate" checked> Cumulative</label>
          <div class="chip">Outbreaks: <span id="outbreak-count">0</span></div>
        </div>
      </div>

      <div class="tb-sec">
        <h4>Map tools</h4>
        <div class="row" style="align-items:center">
          <button id="fit_btn" class="btn">Fit all</button>
          <label>Lat <input type="number" step="any" id="go_lat" placeholder="lat" style="width:6.2rem"></label>
          <label>Lon <input type="number" step="any" id="go_lon" placeholder="lon" style="width:6.2rem"></label>
          <button id="go_btn" class="btn">Go</button>
        </div>
        <div class="row" style="align-items:center; margin-top:.4rem">
          <button id="m_toggle" class="btn">Measure</button>
          <button id="m_clear" class="btn">×</button>
          <span id="m_len" class="muted">0 km</span>
          <button id="map-save" class="btn">Save map PNG</button>
        </div>
      </div>
    </div>
  </aside>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

  <script>
    const PALETTES = ['gray','viridis','plasma','magma','inferno','cividis','terrain','turbo','coolwarm','heat'];

    async function fetchJSON(url){
      const bust = (url.includes('?') ? '&' : '?') + 'v=' + Date.now();
      const r = await fetch(url + bust, {cache:'no-store'});
      const t = await r.text();
      if (!r.ok) throw new Error(`HTTP ${r.status}: ${t.slice(0,160)}`);
      return JSON.parse(t);
    }
    function currentSep(){ const v = document.getElementById("sep").value; return v === "\\t" ? "\t" : v; }
    function fmt(x, d=3){ return (x==null || isNaN(x)) ? "—" : Number(x).toFixed(d); }
    function fmi(x){ return (x==null || isNaN(x)) ? "—" : String(Math.trunc(x)); }
    function chip(text){ const d=document.createElement("div"); d.className="chip"; d.textContent=text; return d; }

    const map = L.map("map").setView([40,-3], 5);
    map.createPane("rasters");  map.getPane("rasters").style.zIndex = 300;
    map.createPane("vectors");  map.getPane("vectors").style.zIndex = 650;

    const baseOSM  = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {attribution:"© OSM", crossOrigin:true}).addTo(map);
    const baseLight = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",{attribution:"© CARTO, OSM", crossOrigin:true});
    const baseSat  = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {crossOrigin:true});
    const base = {"OSM": baseOSM, "Carto Light": baseLight, "ESRI Imagery": baseSat};

    const overlays = {};
    const layerControl = L.control.layers(base, overlays, {collapsed:false}).addTo(map);
    function titleLayerSections(){
      const c = layerControl.getContainer();
      if (!c) return;
      const baseBox = c.querySelector('.leaflet-control-layers-base');
      const overBox = c.querySelector('.leaflet-control-layers-overlays');
      if (baseBox && !baseBox.previousSibling?.classList?.contains('layers-title')){
        const t = document.createElement('div'); t.className='layers-title'; t.textContent='Base maps'; baseBox.parentNode.insertBefore(t, baseBox);
      }
      if (overBox && !overBox.previousSibling?.classList?.contains('layers-title')){
        const t = document.createElement('div'); t.className='layers-title'; t.textContent='Data layers'; overBox.parentNode.insertBefore(t, overBox);
      }
    }
    setTimeout(()=>{ layerControl.expand(); titleLayerSections(); }, 50);

    L.control.scale({metric:true, imperial:false}).addTo(map);

    const graticule = L.layerGroup();
    for (let lat=-80; lat<=80; lat+=5){
      graticule.addLayer(L.polyline([[lat,-180],[lat,180]], {color:'#999', weight:0.5, opacity:0.4, pane:'vectors'}));
    }
    for (let lon=-180; lon<=180; lon+=5){
      graticule.addLayer(L.polyline([[-85,lon],[85,lon]], {color:'#999', weight:0.5, opacity:0.4, pane:'vectors'}));
    }
    layerControl.addOverlay(graticule, "Graticule");

    function getAllBounds(){
      let b = null;
      Object.values(rasterRegistry).forEach(o=>{ if (o.layer) b = b ? b.extend(o.layer.getBounds()) : o.layer.getBounds(); });
      if (pointsLayer){ const pb = pointsLayer.getBounds(); if (pb && pb.isValid()) b = b ? b.extend(pb) : pb; }
      return b;
    }

    let runCount = 0;
    const rasterRegistry = {};
    let currentRunId = null;

    let pointsLayer = null;
    let pointsAllFeatures = [];
    let dateKeyGlobal = null;
    let timeDates = [];
    let timeIndexOf = {};
    let timeTimer = null;

    let ptStyle = { fillColor:"#7fa6ff", color:"#0b5fff", radius:4, fillOpacity:0.85, weight:1 };

    // Legend (bottom-left)
    const LegCtl = L.Control.extend({
      options: { position:'bottomleft' },
      onAdd: function(){
        const div = L.DomUtil.create('div','leg-panel');
        div.id = 'legend-panel';
        div.innerHTML = '<strong>Legends</strong><div class="muted" style="font-size:.8rem">Click gradient to cycle palette</div><div id="leg-list"></div>';
        L.DomEvent.disableClickPropagation(div);
        return div;
      }
    });
    map.addControl(new LegCtl());

    // Single toggle button to show/hide BOTH legend and layers control
    const PanelsToggle = L.Control.extend({
      options:{ position:'topleft' },
      onAdd: function(){
        const container = L.DomUtil.create('div','leaflet-bar');
        const a = L.DomUtil.create('a','',container);
        a.href = '#';
        a.title = 'Show/Hide legend and layer list';
        a.innerHTML = '☰';
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.on(a,'click',L.DomEvent.stop)
                  .on(a,'click',()=>{
                    const lc = layerControl.getContainer();
                    const leg = document.getElementById('legend-panel');
                    const willShow = (lc?.style.display==='none' || leg?.style.display==='none');
                    setLayerControlVisible(willShow);
                    setLegendVisible(willShow);
                  });
        return container;
      }
    });
    map.addControl(new PanelsToggle());

    function drawGrad(canvas, palette){
      const ctx = canvas.getContext('2d');
      const w = canvas.width = 220, h = canvas.height = 12;
      const grd = ctx.createLinearGradient(0,0,w,0);
      const P = {
        viridis:[[0,[68,1,84]],[.25,[59,82,139]],[.5,[33,145,140]],[.75,[94,201,98]],[1,[253,231,37]]],
        plasma:[[0,[13,8,135]],[.25,[126,3,168]],[.5,[203,71,119]],[.75,[248,149,64]],[1,[240,249,33]]],
        magma:[[0,[0,0,4]],[.25,[84,15,109]],[.5,[187,55,84]],[.75,[249,142,9]],[1,[252,255,164]]],
        inferno:[[0,[0,0,3]],[.25,[87,15,109]],[.5,[187,55,84]],[.75,[249,142,9]],[1,[252,255,164]]],
        cividis:[[0,[0,32,77]],[.25,[44,81,96]],[.5,[90,123,101]],[.75,[160,178,86]],[1,[255,233,69]]],
        terrain:[[0,[0,120,0]],[.25,[173,221,142]],[.5,[255,255,191]],[.75,[253,174,97]],[1,[215,25,28]]],
        turbo:[[0,[48,18,59]],[.25,[31,154,170]],[.5,[52,209,91]],[.75,[236,200,52]],[1,[220,47,2]]],
        coolwarm:[[0,[59,76,192]],[.5,[221,221,221]],[1,[180,4,38]]],
        heat:[[0,[0,0,128]],[.25,[0,255,255]],[.5,[255,255,0]],[.75,[255,128,0]],[1,[128,0,0]]],
        gray:[[0,[0,0,0]],[1,[255,255,255]]]
      }[palette] || [[0,[0,0,0]],[1,[255,255,255]]];
      for (const [p,[r,g,b]] of P) grd.addColorStop(p,`rgb(${r},${g},${b})`);
      ctx.fillStyle = grd; ctx.fillRect(0,0,w,h);
    }
    function updateLegendsUI(){
      const list = document.getElementById('leg-list');
      list.innerHTML = '';
      Object.values(rasterRegistry).forEach(info=>{
        const div = document.createElement('div'); div.className='leg-item';
        const head = document.createElement('div'); head.className='leg-head';
        head.innerHTML = `<span>${info.name}</span><span class="muted" style="font-size:.8rem">${info.palette}</span>`;
        const canvas = document.createElement('canvas'); canvas.className='leg-grad';
        drawGrad(canvas, info.palette);
        canvas.addEventListener('click', async ()=>{
          const idx = (PALETTES.indexOf(info.palette)+1) % PALETTES.length;
          await renderRasterWithPalette(info.runId, info.kind, PALETTES[idx], info);
          updateLegendsUI();
        });
        const meta = document.createElement('div'); meta.className='leg-meta';
        meta.innerHTML = `<span>auto 2–98%</span><span>PNG overlay</span>`;
        div.appendChild(head); div.appendChild(canvas); div.appendChild(meta);
        list.appendChild(div);
      });
      titleLayerSections();
    }

    function fillSelectOptions(sel, headers, preferred){
      sel.innerHTML = "";
      headers.forEach(h=>{ const opt=document.createElement("option"); opt.value=h; opt.textContent=h; sel.appendChild(opt); });
      const idx = headers.findIndex(h => h.toLowerCase() === preferred);
      if(idx>=0) sel.selectedIndex = idx;
    }
    document.getElementById("preview").onclick = async () => {
      const f = document.getElementById("csvfile").files[0];
      if(!f){ alert("Select a CSV"); return; }
      const sep = currentSep();
      Papa.parse(f, {
        delimiter: sep, header: true, dynamicTyping: false, preview: 200, skipEmptyLines: true,
        complete: res => {
          const data = res.data || [];
          if(!data.length){ alert("Empty CSV or wrong separator"); return; }
          const headers = res.meta.fields || Object.keys(data[0]);
          fillSelectOptions(document.getElementById("lon_field"), headers, "lon");
          fillSelectOptions(document.getElementById("lat_field"), headers, "lat");
          fillSelectOptions(document.getElementById("date_field"), headers, "date");
          fillSelectOptions(document.getElementById("id_field"), headers, "id");
          fillSelectOptions(document.getElementById("weight_field"), headers, "weight");
          const tbl = document.getElementById("preview-table");
          tbl.innerHTML = "";
          const thead = document.createElement("thead");
          const trh = document.createElement("tr");
          headers.forEach(h=>{ const th=document.createElement("th"); th.textContent=h; trh.appendChild(th); });
          thead.appendChild(trh);
          const tbody = document.createElement("tbody");
          data.slice(0,50).forEach(r=>{
            const tr=document.createElement("tr");
            headers.forEach(h=>{ const td=document.createElement("td"); td.textContent = r[h]; tr.appendChild(td); });
            tbody.appendChild(tr);
          });
          tbl.appendChild(thead); tbl.appendChild(tbody);
          document.getElementById("preview-wrap").style.display = "";
          const info = document.getElementById("preview-info");
          info.style.display = "";
          info.innerHTML = "";
          info.appendChild(chip(`Rows (preview): ${data.length}`));
          info.appendChild(chip(`Separator: ${sep === "\t" ? "tab" : sep}`));
        }
      });
    };
    document.getElementById("close-preview").onclick = () => {
      document.getElementById("preview-wrap").style.display = "none";
      document.getElementById("preview-info").style.display = "none";
    };

    function addImage(runId, kind, url, bounds, name){
      const layer = L.imageOverlay(url, bounds, {opacity:0.85, pane:"rasters"}).addTo(map);
      const key = `${runId}:${kind}`;
      rasterRegistry[key] = { runId, kind, layer, bounds, palette:'gray', name };
      overlays[name] = layer; layerControl.addOverlay(layer, name);
      try { map.fitBounds(layer.getBounds()); } catch {}
      refreshRasterSelect();
      updateLegendsUI();
      layerControl.expand();
    }
    function refreshRasterSelect(){
      const sel = document.getElementById("raster_layer");
      const cur = sel.value;
      sel.innerHTML = "";
      Object.values(rasterRegistry).forEach(info=>{
        const opt = document.createElement('option');
        opt.value = `${info.runId}:${info.kind}`;
        opt.textContent = info.name;
        sel.appendChild(opt);
      });
      if (cur) sel.value = cur;
    }
    async function renderRasterWithPalette(runId, kind, palette, infoRef=null){
      const js = await fetchJSON(`/render?run_id=${encodeURIComponent(runId)}&kind=${encodeURIComponent(kind)}&palette=${encodeURIComponent(palette)}`);
      const key = `${runId}:${kind}`;
      const info = infoRef || rasterRegistry[key];
      if (!info) return;
      info.layer.setUrl(js.url);
      info.palette = palette;
      const sel = document.getElementById("raster_layer");
      if (sel.value === key){ document.getElementById("palette").value = palette; }
    }
    document.getElementById("raster_opacity").addEventListener("input", (e)=>{
      const sel = document.getElementById("raster_layer").value;
      const info = rasterRegistry[sel]; if (!info) return;
      info.layer.setOpacity(parseFloat(e.target.value));
    });

    document.getElementById('map-save').addEventListener('click', ()=>{
      leafletImage(map, function(err, canvas){
        if (err){ alert('Cannot render map (CORS on tiles)'); return; }
        const a = document.createElement('a');
        a.download = 'frontwave_map.png';
        a.href = canvas.toDataURL('image/png');
        a.click();
      });
    });

    const mapEl = document.getElementById('map');
    document.getElementById('map_h').addEventListener('input', (e)=>{
      mapEl.style.height = `${e.target.value}px`; map.invalidateSize();
    });
    let maximized=false;
    document.getElementById('map_max').addEventListener('click', ()=>{
      maximized = !maximized;
      mapEl.style.height = maximized ? '85vh' : `${document.getElementById('map_h').value}px`;
      map.invalidateSize();
      document.getElementById('map_max').textContent = maximized ? 'Restore' : 'Maximize';
    });

    function toISODate(s){
      if (s == null || s === "") return null;
      const m = String(s).match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})/);
      if (m) return `${m[1]}-${m[2].padStart(2,'0')}-${m[3].padStart(2,'0')}`;
      const d = new Date(s);
      return isNaN(d) ? null : d.toISOString().slice(0,10);
    }
    function geojsonPointStyle(){ return {
      pane:"vectors",
      radius: ptStyle.radius,
      color: ptStyle.color,
      weight: ptStyle.weight,
      fillColor: ptStyle.fillColor,
      fillOpacity: ptStyle.fillOpacity
    };}

    function restylePoints(){
      if (!pointsLayer) return;
      pointsLayer.setStyle({
        color: ptStyle.color, weight: ptStyle.weight,
        fillColor: ptStyle.fillColor, fillOpacity: ptStyle.fillOpacity
      });
      pointsLayer.eachLayer(l => { if (l.setRadius) l.setRadius(ptStyle.radius); });
    }
    document.getElementById("apply-pts-style").addEventListener("click", ()=>{
      ptStyle.fillColor = document.getElementById("pt_color").value || ptStyle.fillColor;
      ptStyle.color     = document.getElementById("pt_stroke").value || ptStyle.color;
      ptStyle.radius    = Math.max(1, Number(document.getElementById("pt_size").value)||ptStyle.radius);
      ptStyle.fillOpacity = Number(document.getElementById("pt_opacity").value)||ptStyle.fillOpacity;
      restylePoints();
    });

    function renderPointsAt(idx){
      const slider = document.getElementById("time");
      if (typeof idx !== "number") idx = parseInt(slider.value);
      const tcurEl = document.getElementById("time-current");
      if (!timeDates.length){
        tcurEl.textContent = "—";
        if (pointsLayer) pointsLayer.clearLayers();
        document.getElementById('outbreak-count').textContent = '0';
        return;
      }
      const cutoff = timeDates[Math.max(0, Math.min(idx, timeDates.length-1))];
      tcurEl.textContent = cutoff;

      const cum = document.getElementById("cumulate").checked;
      const feats = pointsAllFeatures.filter(f=>{
        const v = f?.properties?.DATE_ISO || f?.properties?.[dateKeyGlobal];
        const iso = toISODate(v);
        if (!iso) return false;
        const i = timeIndexOf[iso];
        if (typeof i !== "number") return false;
        return cum ? (i <= idx) : (i === idx);
      });
      if (!pointsLayer){
        pointsLayer = L.geoJSON({type:"FeatureCollection", features:feats}, {
          pane:'vectors',
          pointToLayer: (f, latlng) => L.circleMarker(latlng, geojsonPointStyle())
        }).addTo(map);
        const name = `CSV points _${runCount}`;
        overlays[name] = pointsLayer; layerControl.addOverlay(pointsLayer, name);
      } else {
        pointsLayer.clearLayers();
        pointsLayer.addData({type:"FeatureCollection", features:feats});
      }
      document.getElementById('outbreak-count').textContent = String(feats.length);
    }

    document.getElementById("time").addEventListener("input", e => renderPointsAt(parseInt(e.target.value)));
    document.getElementById("cumulate").addEventListener("change", () => renderPointsAt());
    document.getElementById("play").addEventListener("click", () => {
      if (timeTimer) return;
      const slider = document.getElementById("time");
      let i = parseInt(slider.value);
      timeTimer = setInterval(()=>{
        if (!timeDates.length){ clearInterval(timeTimer); timeTimer=null; return; }
        i = (i + 1 <= parseInt(slider.max)) ? i + 1 : 0;
        slider.value = i;
        renderPointsAt(i);
      }, 600);
    });
    document.getElementById("pause").addEventListener("click", () => { if (timeTimer){ clearInterval(timeTimer); timeTimer = null; } });

    let velChart = null;
    let velStats = null;

    function buildHistogram(stats, requestedBins){
      const edges = stats.hist_bins || [];
      const counts = stats.hist_counts || [];
      const M = Math.max(0, edges.length-1);
      if (M === 0) return {labels:[], counts:[], edges:[]};

      const allowed = [6,8,12,16,20,24,28,32,36,40,44,48].filter(d => M % d === 0);
      let target = requestedBins || M;
      let snapped = allowed.length ? allowed.reduce((a,b)=> Math.abs(b-target) < Math.abs(a-target) ? b : a, allowed[0]) : Math.min(Math.max(6, target), 48);
      const g = Math.max(1, Math.round(M / snapped));

      const newCounts = [], newEdges = [];
      for(let i=0;i<M;i+=g){
        let s=0; for(let k=i;k<Math.min(i+g, M);k++) s += counts[k];
        newCounts.push(s); newEdges.push(edges[i]);
      }
      newEdges.push(edges[M]);
      const labels = [];
      for(let i=0;i<newCounts.length;i++){ labels.push(`${fmt(newEdges[i],2)}–${fmt(newEdges[i+1],2)}`); }
      return {labels, counts:newCounts, edges:newEdges, snapped:newCounts.length};
    }

    function renderVelocitySummary(stats){
      velStats = stats;
      const card = document.getElementById("stats-card");
      if(!stats || !Number.isFinite(stats.count)){ card.style.display="none"; return; }
      card.style.display="";
      document.getElementById("vel-n").textContent   = fmi(stats.count);
      document.getElementById("vel-mean").textContent= fmt(stats.mean);
      document.getElementById("vel-med").textContent = fmt(stats.p50);
      document.getElementById("vel-min").textContent = fmt(stats.min);
      document.getElementById("vel-max").textContent = fmt(stats.max);
      document.getElementById("vel-std").textContent = fmt(stats.std);
      const ci = (stats.ci95_low!=null && stats.ci95_high!=null) ? `${fmt(stats.ci95_low)}–${fmt(stats.ci95_high)}` : "—";
      document.getElementById("vel-ci").textContent = ci;
      drawHistogram();
    }

    function drawHistogram(){
      if (!velStats){ return; }
      const requested = parseInt(document.getElementById('bins_slider').value);
      const {labels, counts, edges, snapped} = buildHistogram(velStats, requested);
      document.getElementById('bins_label').textContent = String(snapped);

      const mean = velStats.mean, std = velStats.std, med = velStats.p50;
      const ctx = document.getElementById("velChart").getContext("2d");
      if (velChart) velChart.destroy();

      const cfg = {
        type: 'bar',
        data: { labels, datasets: [{ label: 'Velocity histogram', data: counts, borderWidth: 1 }] },
        options: {
          responsive:true, maintainAspectRatio:false,
          plugins:{
            legend:{ display:false },
            annotation:{
              annotations:{
                stdBand:{ type:'box',
                  xMin:(()=>{ let x=mean-std; let i=edges.findIndex(v=>v>=x); return Math.max(0,i-1); })(),
                  xMax:(()=>{ let x=mean+std; let i=edges.findIndex(v=>v>=x); return Math.max(0,Math.min(labels.length-1,i-1)); })(),
                  backgroundColor:'rgba(0, 123, 255, 0.10)', borderWidth:0
                },
                meanLine:{ type:'line',
                  xMin:(()=>{ let i=edges.findIndex(v=>v>=mean); return Math.max(0,i-1); })(),
                  xMax:(()=>{ let i=edges.findIndex(v=>v>=mean); return Math.max(0,i-1); })(),
                  borderColor:'#0b5fff', borderWidth:2,
                  label:{ display:true, content:`mean ${fmt(mean,2)}`, position:'start', backgroundColor:'rgba(11,95,255,.15)' }
                },
                medLine:{ type:'line',
                  xMin:(()=>{ let i=edges.findIndex(v=>v>=med); return Math.max(0,i-1); })(),
                  xMax:(()=>{ let i=edges.findIndex(v=>v>=med); return Math.max(0,i-1); })(),
                  borderColor:'#444', borderDash:[6,4], borderWidth:2,
                  label:{ display:true, content:`median ${fmt(med,2)}`, position:'end', backgroundColor:'rgba(0,0,0,.08)' }
                }
              }
            },
            tooltip:{ callbacks:{
              afterBody:(ctx)=>{
                const i = ctx[0].dataIndex;
                const lo = edges[i]; const hi = edges[i+1];
                return [`bin: ${fmt(lo,2)}–${fmt(hi,2)}`, `within mean±SD: ${ (lo<=mean+std && hi>=mean-std) ? 'yes':'no' }`];
              }
            }}
          },
          scales:{
            x:{ title:{ display:true, text:'Velocity' }, ticks:{ maxRotation:0, autoSkip:true } },
            y:{ title:{ display:true, text:'Count' }, beginAtZero:true, precision:0 }
          }
        }
      };

      if (document.getElementById('show_cdf').checked){
        const total = counts.reduce((a,b)=>a+b,0)||1;
        let cum=0; const cdf=counts.map(v=>{ cum+=v; return cum/total; });
        cfg.data.datasets.push({ type:'line', label:'CDF', data:cdf, yAxisID:'y1', pointRadius:0, borderWidth:2 });
        cfg.options.scales.y1 = { position:'right', min:0, max:1, title:{display:true, text:'CDF'} };
      }
      velChart = new Chart(ctx, cfg);
    }

    document.getElementById('bins_slider').addEventListener('input', drawHistogram);
    document.getElementById('bins_minus').addEventListener('click', ()=>{
      const s = document.getElementById('bins_slider'); s.value = Math.max(parseInt(s.min), parseInt(s.value)-1); drawHistogram();
    });
    document.getElementById('bins_plus').addEventListener('click', ()=>{
      const s = document.getElementById('bins_slider'); s.value = Math.min(parseInt(s.max), parseInt(s.value)+1); drawHistogram();
    });
    document.getElementById('show_cdf').addEventListener('change', drawHistogram);

    let measureMode=false, measureLine=null;
    function measureUpdate(){
      if (!measureLine) return;
      const latlngs = measureLine.getLatLngs();
      let m=0; for(let i=1;i<latlngs.length;i++){ m += map.distance(latlngs[i-1], latlngs[i]); }
      document.getElementById('m_len').textContent = (m/1000).toFixed(3)+' km';
    }
    map.on('click', e=>{
      if (!measureMode) return;
      if (!measureLine){ measureLine = L.polyline([e.latlng],{color:'#111',weight:2,opacity:.85}).addTo(map); }
      else { measureLine.addLatLng(e.latlng); }
      measureUpdate();
    });
    document.getElementById('m_toggle').addEventListener('click', ()=>{
      measureMode = !measureMode;
      document.getElementById('m_toggle').textContent = measureMode ? 'Measuring…' : 'Measure';
    });
    document.getElementById('m_clear').addEventListener('click', ()=>{
      if (measureLine){ map.removeLayer(measureLine); measureLine=null; }
      document.getElementById('m_len').textContent='0 km';
    });
    document.getElementById('fit_btn').addEventListener('click', ()=>{
      const bnd = getAllBounds(); if (bnd) map.fitBounds(bnd.pad(0.05));
    });
    document.addEventListener('click', (e)=>{
      if(e.target && e.target.id==='go_btn'){
        const lat = parseFloat(document.getElementById('go_lat').value);
        const lon = parseFloat(document.getElementById('go_lon').value);
        if (isFinite(lat)&&isFinite(lon)) map.setView([lat,lon], 12);
      }
    });

    document.getElementById("apply-style").onclick = async () => {
      const key = document.getElementById("raster_layer").value; if (!key) { alert("Select a raster layer"); return; }
      const info = rasterRegistry[key]; if (!info) { alert("Layer missing"); return; }
      const pal  = document.getElementById("palette").value;
      await renderRasterWithPalette(info.runId, info.kind, pal, info);
      updateLegendsUI();
    };

    document.getElementById("process").onclick = async () => {
      const f = document.getElementById("csvfile").files[0];
      if(!f){ alert("Select a CSV"); return; }

      const fd = new FormData();
      fd.append("csv_file", f);
      fd.append("grid", document.getElementById("grid").value || 12000);
      fd.append("cell", document.getElementById("cell").value || 1200);
      fd.append("contour", document.getElementById("contour").value || 30);
      fd.append("sep", document.getElementById("sep").value);
      fd.append("lon_field", document.getElementById("lon_field").value || "lon");
      fd.append("lat_field", document.getElementById("lat_field").value || "lat");
      fd.append("date_field", document.getElementById("date_field").value || "date");
      fd.append("id_field", document.getElementById("id_field").value || "id");
      fd.append("weight_field", document.getElementById("weight_field").value || "weight");
      fd.append("kriging_model", document.getElementById("kriging_model").value);
      fd.append("variogram_model", document.getElementById("variogram_model").value);
      const vs = document.getElementById("var_sill").value.trim(); if (vs!=="") fd.append("var_sill", vs);
      const vr = document.getElementById("var_range").value.trim(); if (vr!=="") fd.append("var_range", vr);
      const vn = document.getElementById("var_nugget").value.trim(); if (vn!=="") fd.append("var_nugget", vn);
      fd.append("nlags", document.getElementById("nlags").value || 6);
      fd.append("weight", document.getElementById("use_weights").checked ? "true" : "false");

      const r = await fetch("/run", { method:"POST", body:fd });
      const js = await r.json();

      runCount += 1;
      currentRunId = js.run_id;
      const suffix = `_${runCount}`;

      const ul = document.getElementById("downloads");
      ul.innerHTML="";
      const nice = {
        kriging:"Kriging surface (GeoTIFF)", slope:"Slope (GeoTIFF)", velocity:"Velocity (GeoTIFF)",
        contours:"Iso-contours (GPKG)", ellipse:"Standard deviation ellipse (GPKG)",
        selected_points:"Selected points (GPKG)", all_points:"All points (GPKG)", grid:"Grid (GPKG)",
        selected_points_geojson:"Selected points (GeoJSON)", all_points_geojson:"All points (GeoJSON)",
        ellipse_geojson:"Ellipse (GeoJSON)", contours_geojson:"Contours (GeoJSON)", bundle_zip:"Full bundle (ZIP)"
      };
      for (const [k,v] of Object.entries(js.urls)) {
        if (v) {
          const li = document.createElement("li");
          li.innerHTML = `<a href="${v}" target="_blank" rel="noopener">${nice[k]||k}</a>`;
          ul.appendChild(li);
        }
      }
      const bz = js.urls.bundle_zip;
      const chipWrap = document.getElementById("bundle-chip");
      chipWrap.style.display = bz ? "" : "none";
      chipWrap.innerHTML = bz ? `<a class="btn btn-primary" href="${bz}" target="_blank" rel="noopener">Download all outputs as ZIP</a>` : "";

      renderVelocitySummary(js?.stats?.velocity);

      const names = {kriging:`Kriging surface ${suffix}`, slope:`Slope ${suffix}`, velocity:`Velocity ${suffix}`};
      if (js.images?.kriging)  addImage(js.run_id, "kriging",  js.images.kriging.url,  js.images.kriging.bounds,  names.kriging);
      if (js.images?.slope)    addImage(js.run_id, "slope",    js.images.slope.url,    js.images.slope.bounds,    names.slope);
      if (js.images?.velocity) addImage(js.run_id, "velocity", js.images.velocity.url, js.images.velocity.bounds, names.velocity);

      if (js.urls.contours_geojson) {
        const gj = await fetchJSON(js.urls.contours_geojson);
        const layer = L.geoJSON(gj, {pane:'vectors', style:{color:"#0066cc", weight:1.5, opacity:0.9}}).addTo(map);
        const nm = `Iso-contours ${suffix}`;
        overlays[nm] = layer; layerControl.addOverlay(layer, nm);
      }
      if (js.urls.ellipse_geojson) {
        const gj = await fetchJSON(js.urls.ellipse_geojson);
        const layer = L.geoJSON(gj, {pane:'vectors', style:{color:"#aa8800", weight:2, fillColor:"#ffdd77", fillOpacity:0.25}}).addTo(map);
        const nm = `Std. deviation ellipse ${suffix}`;
        overlays[nm] = layer; layerControl.addOverlay(layer, nm);
      }

      if (pointsLayer) { try{ layerControl.removeLayer(pointsLayer); map.removeLayer(pointsLayer); }catch{} pointsLayer = null; }
      pointsAllFeatures = [];
      if (js.urls.all_points_geojson){
        const gj = await fetchJSON(js.urls.all_points_geojson);
        pointsAllFeatures = Array.isArray(gj.features) ? gj.features : [];
        dateKeyGlobal = "DATE_ISO";
        const dates = pointsAllFeatures.map(f => {
          const v = f?.properties?.DATE_ISO || f?.properties?.[js?.meta?.date_field || 'date'];
          return toISODate(v);
        }).filter(Boolean);
        const uq = Array.from(new Set(dates)).sort();
        timeDates = uq;
        timeIndexOf = Object.fromEntries(uq.map((d,i)=>[d,i]));
        const slider = document.getElementById("time");
        const tstart = document.getElementById("time-start");
        const tend   = document.getElementById("time-end");
        const tcur   = document.getElementById("time-current");
        if (!uq.length){
          slider.disabled = true; slider.min=0; slider.max=0; slider.value=0; tstart.textContent="—"; tend.textContent="—"; tcur.textContent="—";
        } else {
          slider.min=0; slider.max=uq.length-1; slider.value=uq.length-1; slider.disabled=false;
          tstart.textContent = uq[0]; tend.textContent = uq[uq.length-1]; tcur.textContent = uq[uq.length-1];
        }
        pointsLayer = L.geoJSON({type:"FeatureCollection", features:[]}, {
          pane:'vectors',
          pointToLayer: (f, latlng) => L.circleMarker(latlng, geojsonPointStyle())
        }).addTo(map);
        const pName = `CSV points ${suffix}`;
        overlays[pName] = pointsLayer; layerControl.addOverlay(pointsLayer, pName);
        renderPointsAt(parseInt(slider.value));
      }

      layerControl.expand();
      titleLayerSections();

      const lg = document.getElementById("run-log");
      const card = document.createElement('div');
      card.className = 'chip';
      const p = js.meta?.params || {};
      const npts = pointsAllFeatures.length;
      const t0 = timeDates[0] || '—', t1 = timeDates[timeDates.length-1] || '—';
      card.innerHTML = `Run ${runCount} · Grid ${p.grid_m} m · Cell ${p.cell_m} m · Contour ${p.contour} · ${p.kriging_model}/${p.variogram_model} lags=${p.nlags} weighted=${p.weight} · Points ${npts} · ${t0} → ${t1}`;
      lg.prepend(card);
    };

    document.getElementById("raster_layer").addEventListener('change', (e)=>{
      const info = rasterRegistry[e.target.value];
      if (!info) return;
      document.getElementById("palette").value = info.palette || 'gray';
    });

    const tb = document.getElementById('toolbox');
    const tbt = document.getElementById('toolbox-toggle');
    const tbc = document.getElementById('toolbox-close');
    function setTb(open){
      tb.classList.toggle('open', open);
      tbt.setAttribute('aria-expanded', open ? 'true' : 'false');
    }
    tbt.addEventListener('click', ()=> setTb(!tb.classList.contains('open')));
    tbc.addEventListener('click', ()=> setTb(false));

    function setLayerControlVisible(show){
      const c = layerControl.getContainer();
      if (c) c.style.display = show ? '' : 'none';
    }
    function setLegendVisible(show){
      const leg = document.getElementById('legend-panel');
      if (leg) leg.style.display = show ? '' : 'none';
    }
    document.getElementById('show_layerctl').addEventListener('change', e=> setLayerControlVisible(e.target.checked));
    document.getElementById('show_legend').addEventListener('change', e=> setLegendVisible(e.target.checked));
  </script>
</body>
</html>
